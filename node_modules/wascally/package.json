{
  "name": "wascally",
  "version": "0.2.4",
  "description": "Abstractions to simplify working with the wascally wabbitMQ",
  "main": "src/index.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/leankit-labs/wascally"
  },
  "scripts": {
    "test": "gulp coverage"
  },
  "publishConfig": {
    "registry": "https://registry.npmjs.org/"
  },
  "author": {
    "name": "LeanKit"
  },
  "contributors": [
    {
      "name": "Alex Robson",
      "email": "asrobson@gmail.com",
      "url": "http://github.com/arobson"
    },
    {
      "name": "Doug Neiner",
      "url": "http://code.dougneiner.com"
    },
    {
      "name": "Derick Bailey",
      "url": "http://derickbailey.com/"
    },
    {
      "name": "John Mathis",
      "url": "http://github.com/JohnDMathis"
    },
    {
      "name": "Austin Young",
      "url": "http://github.com/LeankitAustin"
    },
    {
      "name": "Scott Walters",
      "url": "http://github.com/LeankitScott"
    },
    {
      "name": "Eric Satterwhite",
      "url": "http://codedependant.net/"
    },
    {
      "name": "Leonardo Bispo de Oliveira",
      "url": "http://blog.bispooliveira.de"
    }
  ],
  "license": "MIT License - http://opensource.org/licenses/MIT",
  "devDependencies": {
    "gulp": "~3.8.1",
    "biggulp": "0.*.*",
    "chai": "^2.0.0",
    "chai-as-promised": "^4.2.0",
    "sinon": "^1.12.2"
  },
  "dependencies": {
    "amqplib": "~0.3.0",
    "debug": "^2.1.1",
    "lodash": "~2.4.1",
    "machina": "^0.3.6",
    "monologue.js": "~0.1.4",
    "node-uuid": "^1.4.1",
    "postal": "1.0.*",
    "when": "~3.0.0",
    "whistlepunk": "0.2.0"
  },
  "readme": "# Wascally\nThis is a very opinionated abstraction over amqplib to help simplify certain common tasks and (hopefully) reduce the effort required to use RabbitMQ in your Node services.\n\n### Features:\n\n * Gracefully handle re-connections\n * Automatically re-define all topology on re-connection\n * Automatically re-send any unconfirmed messages on re-connection\n * Support the majority of RabbitMQ's extensions\n * Handle batching of acknowledgements and rejections\n * Topology & configuration via the JSON configuration method (thanks to @JohnDMathis!)\n\n### Assumptions & Defaults:\n\n * Fault-tolerance/resilience over throughput\n * Default to publish confirmation\n * Default to ack mode on consumers\n * Heterogenous services that include statically typed languages\n * JSON as the only serialization provider\n\n### Demos\n\n * [pubsub](https://github.com/LeanKit-Labs/wascally/blob/master/demo/pubsub/README.md)\n\n# API Reference\nThis library implements promises for many of the calls via when.js.\n\n## Sending & Receiving Messages\n\n### publish( exchangeName, options, [connectionName] )\nThis syntax uses an options object rather than arguments, here's an example showing all of the available properties:\n\n```javascript\nrabbit.publish( 'exchange.name', {\n\t\troutingKey: 'hi',\n\t\ttype: 'company.project.messages.textMessage',\n\t\tcorrelationId: 'one',\n\t\tbody: { text: 'hello!' },\n\t\tmessageId: '100',\n\t\texpiresAfter: 1000 // TTL in ms, in this example 1 second\n\t\ttimestamp: // posix timestamp (long)\n\t\theaders: {\n\t\t\t'random': 'application specific value'\n\t\t}\n\t},\n\tconnectionName: '' // another optional way to provide connection name if needed\n);\n```\n\n### publish( exchangeName, typeName, messageBody, [routingKey], [correlationId], [connectionName] )\nMessages bodies are simple objects. A type specifier is required for the message which will be used to set AMQP's properties.type. If no routing key is provided, the type specifier will be used. A routing key of '' will prevent the type specifier from being used.\n\n```javascript\n// the first 3 arguments are required\n// routing key is optional and defaults to the value of typeName\n// connectionName is only needed if you have multiple connections to different servers or vhosts\n\nrabbit.publish( 'log.entries', 'company.project.messages.logEntry', {\n\t\tdate: Date.now(),\n\t\tlevel: logLevel,\n\t\tmessage: message\n\t}, 'log.' + logLevel, someValueToCorrelateBy );\n```\n\n### request( exchangeName, options, [connectionName] )\nThis works just like a publish except that the promise returned provides the response (or responses) from the other side.\n\n```javascript\n// when multiple responses are provided, all but the last will be provided via the .progress callback.\n// the last/only reply will always be provided to the .then callback\nrabbit.request( 'request.exchange', {\n\t\t// see publish example to see options for the outgoing message\n\t} )\n\t.progress( function( reply ) {\n\t\t// if multiple replies are provided, all but the last will be sent via the progress callback\n\t} )\n\t.then( function( final ) {\n\t\t// the last message in a series OR the only reply will be sent to this callback\n\t} );\n```\n\n### handle( typeName, handler, [context] )\n\n> Handle calls should happen __before__ starting subscriptions.\n\nMessage handlers are registered to handle a message based on the typeName. Calling handle will return a reference to the handler that can later be removed. The message that is passed to the handler is the raw Rabbit payload. The body property contains the message body published. The message has `ack`, `nack` (requeue the message) and `reject` (don't requeue the message) methods control what Rabbit does with the message.\n\n#### Explicit Error Handling\nIn this example, any possible error is caught in an explicit try/catch:\n\n```javascript\nvar handler = rabbit.handle( 'company.project.messages.logEntry', function( message ) {\n\ttry {\n\t\t// do something meaningful?\n\t\tconsole.log( message.body );\n\t\tmessage.ack();\n\t} catch( err ) {\n\t\tmessage.nack();\n\t}\n} );\n\nhandler.remove();\n```\n\n#### Automatically Nack On Error\nThis example shows how to have wascally wrap all handlers with a try catch that:\n\n * nacks the message on error\n * console.log that an error has occurred in a handle\n\n```javascript\n// after this call, any new callbacks attached via handle will be wrapped in a try/catch\n// that nacks the message on an error\nrabbit.nackOnError();\n\nvar handler = rabbit.handle( 'company.project.messages.logEntry', function( message ) {\n\tconsole.log( message.body );\n\tmessage.ack();\n} );\n\nhandler.remove();\n\n// after this call, new callbacks attached via handle will *not* be wrapped in a try/catch\nrabbit.ignoreHandlerErrors();\n```\n\n#### Late-bound Error Handling\nProvide a strategy for handling errors to multiple handles or attach an error handler after the fact.\n\n```javascript\nvar handler = rabbit.handle( 'company.project.messages.logEntry', function( message ) {\n\tconsole.log( message.body );\n\tmessage.ack();\n} );\n\nhandler.catch( function( err, msg ) {\n\t// do something with the error & message\n\tmsg.nack();\n} );\n```\n\n#### !!! IMPORTANT !!! ####\nFailure to handle errors will result in silent failures and lost messages.\n\n### Unhandled Messages\nIn previous versions, if a subscription was started in ack mode (the default) without a handler to process the message, the message would get lost in limbo until the connection (or channel) was closed and then the messages would be returned to the queue. This is very confusing and undesirable behavior. To help protect against this, the new default behavior is that any message received that doesn't have any elligible handlers will get `nack`'d and sent back to the queue immediately.\n\nThis is _still_ problematic because it can create churn on the client and server as the message will be redelivered indefinitely.\n\nTo change this behavior, use one of the following calls:\n\n> Note: only one of these strategies can be activated at a time\n\n#### onUnhandled( handler )\n```javascript\nrabbit.onUnhandled( function( message ) {\n\t // handle the message here\n} );\n```\n\n#### nackUnhandled() - default\nSends all unhandled messages back to the queue.\n```javascript\nrabbit.nackUnhandled();\n```\n\n#### rejectUnhandled()\nRejects unhandled messages so that will will _not_ be requeued. **DO NOT** use this unless there are dead letter exchanges for all queues.\n```javascript\nrabbit.rejectUnhandled();\n```\n\n### startSubscription( queueName, [connectionName] )\n\n> Recommendation: set handlers for anticipated types up before starting subscriptions.\n\nStarts a consumer on the queue specified. `connectionName` is optional and only required if subscribing to a queue on a connection other than the default one.\n\n## Message API\nWascally defaults to (and assumes) queues are in ack mode. It batches ack and nack operations in order to improve total throughput. Ack/Nack calls do not take effect immediately.\n\n### message.ack()\nEnqueues the message for acknowledgement.\n\n### message.nack()\nEnqueues the message for rejection. This will re-enqueue the message.\n\n### message.reject()\nRejects the message without re-queueing it. Please use with caution and consider having a dead-letter-exchange assigned to the queue before using this feature.\n\n### message.reply( message, [more], [replyType] )\nAcknowledges the messages and sends the message back to the requestor. The `message` is only the body of the reply. Providing true to `more` will cause the message to get sent to the .progress callback of the request promise so that you can send multiple replies. The `replyType` argument sets the type of the reply message. (important when messaging with statically typed languages)\n\n### Queues in `noBatch` mode\nWascally now supports the ability to put queues into non-batching behavior. This causes ack, nack and reject calls to take place against the channel immediately. This feature is ideal when processing messages are long-running and consumer limits are in place. Be aware that this feature does have a significant impact on message throughput.\n\n## Reply Queues\nBy default, wascally creates a unique reply queue for each connection which is automatically subscribed to and deleted on connection close. This can be modified or turned off altogether.\n\nChanging the behavior is done by passing one of three values to the `replyQueue` property on the connection hash:\n\n> !!! IMPORTANT !!! wascally cannot prevent queue naming collisions across services instances or connections when using the first two options.\n\n### Custom Name\nOnly changes the name of the reply queue that wascally creates - `autoDelete` and `subscribe` will be set to `true`.\n\n```javascript\nrabbit.addConnection( {\n\tname: 'default',\n\treplyQueue: 'myOwnQueue',\n\tuser: 'guest',\n\tpass: 'guest',\n\tserver: '127.0.0.1',\n\tport: 5672,\n\ttimeout: 2000,\n\tvhost: '%2f'\n} );\n```\n\n### Custom Behavior\nTo take full control of the queue name and behavior, provide a queue definition in place of the name.\n\n> wascally provides no defaults - it will only use the definition provided\n\n```javascript\nrabbit.addConnection( {\n\tname: 'default',\n\treplyQueue: {\n\t\tname: 'myOwnQueue',\n\t\tsubscribe: 'true',\n\t\tdurable: true\n\t},\n\tuser: 'guest',\n\tpass: 'guest',\n\tserver: '127.0.0.1',\n\tport: 5672,\n\ttimeout: 2000,\n\tvhost: '%2f'\n} );\n```\n\n### No Automatic Reply Queue\n> Only pick this option if request/response isn't in use or when providing a custom overall strategy\n\n```javascript\nrabbit.addConnection( {\n\tname: 'default',\n\treplyQueue: false,\n\tuser: 'guest',\n\tpass: 'guest',\n\tserver: '127.0.0.1',\n\tport: 5672,\n\ttimeout: 2000,\n\tvhost: '%2f'\n} );\n```\n\n## Managing Topology\n\n### addExchange( exchangeName, exchangeType, [options], [connectionName] )\nThe call returns a promise that can be used to determine when the exchange has been created on the server.\n\nValid exchangeTypes:\n * 'direct'\n * 'fanout'\n * 'topic'\n\nOptions is a hash that can contain the following:\n * autoDelete\t\ttrue|false\t\tdelete when consumer count goes to 0\n * durable \t\t\ttrue|false\t\tsurvive broker restarts\n * persistent \t\ttrue|false\t\ta.k.a. persistent delivery, messages saved to disk\n * alternate \t\t'alt.exchange'\tdefine an alternate exchange\n\n### addQueue( queueName, [options], [connectionName] )\nThe call returns a promise that can be used to determine when the queue has been created on the server.\n\nOptions is a hash that can contain the following:\n * autoDelete\t\ttrue|false\t\tdelete when consumer count goes to 0\n * durable \t\t\ttrue|false\t\tsurvive broker restarts\n * exclusive\t\ttrue|false\t\tlimits queue to the current connection only (danger)\n * subscribe\t\ttrue|false\t\tauto-start the subscription\n * limit \t\t\t2^16\t\t\tmax number of unacked messages allowed for consumer\n * noAck\t\t\ttrue|false \t\tthe server will remove messages from the queue as soon as they are delivered\n * noBatch\t\t\ttrue|false \t\tcauses ack, nack & reject to take place immediately\n * queueLimit\t\t2^32\t\t\tmax number of ready messages a queue can hold\n * messageTtl\t\t2^32\t\t\ttime in ms before a message expires on the queue\n * expires\t\t\t2^32\t\t\ttime in ms before a queue with 0 consumers expires\n * deadLetter \t\t'dlx.exchange'\tthe exchange to dead-letter messages to\n\n### bindExchange( sourceExchange, targetExchange, [routingKeys], [connectionName] )\nBinds the target exchange to the source exchange. Messages flow from source to target.\n\n### bindQueue( sourceExchange, targetQueue, [routingKeys], [connectionName] )\nBinds the target queue to the source exchange. Messages flow from source to target.\n\n## Configuration via JSON\n\n> Note: setting subscribe to true will result in subscriptions starting immediately upon queue creation.\n\nThis example shows most of the available options described above.\n```javascript\n\tvar settings = {\n\t\tconnection: {\n\t\t\tuser: 'guest',\n\t\t\tpass: 'guest',\n\t\t\tserver: '127.0.0.1',\n\t\t\tport: 5672,\n\t\t\ttimeout: 2000,\n\t\t\tvhost: '%2fmyhost'\n\t\t\t},\n\t\texchanges:[\n\t\t\t{ name: 'config-ex.1', type: 'fanout'  },\n\t\t\t{ name: 'config-ex.2', type: 'topic', alternate: 'alternate-ex.2', persistent: true },\n\t\t\t{ name: 'dead-letter-ex.2', type: 'fanout' }\n\t\t\t],\n\t\tqueues:[\n\t\t\t{ name:'config-q.1', limit: 100, queueLimit: 1000 },\n\t\t\t{ name:'config-q.2', subscribe: true, deadLetter: 'dead-letter-ex.2' }\n\t\t\t],\n\t\tbindings:[\n\t\t\t{ exchange: 'config-ex.1', target: 'config-q.1', keys: [ 'bob','fred' ] },\n\t\t\t{ exchange: 'config-ex.2', target: 'config-q.2', keys: 'test1' }\n\t\t]\n\t};\n```\n\nTo establish a connection with all settings in place and ready to go call configure:\n```javascript\n\tvar rabbit = require( 'wascally' );\n\n\trabbit.configure( settings ).done( function() {\n\t\t// ready to go!\n\t} );\n```\n\n## Closing Connections\nWascally will attempt to resolve all outstanding publishes and recieved messages (ack/nack/reject) before closing the channels and connection. If you would like to defer certain actions until after everything has been safely resolved, then use the promise returned from either close call.\n\n> !!! CAUTION !!! - using reset is dangerous. All topology associated with the connection will be removed meaning wasclly will not be able to re-establish it all should you decide to reconnect.\n\n### close( [connectionName], [reset] )\nCloses the connection, optionall resetting all previously defined topology for the connection. The `connectionName` uses `default` if one is not provided.\n\n### closeAll( [reset] )\nCloses __all__ connections, optionally resetting the topology for all of them.\n\n## AMQPS, SSL/TLS Support\nProviding the following configuration options setting the related environment varibles will cause wascally to attempt connecting via AMQPS. For more details about which settings perform what role, refer to the amqplib's page on [SSL](http://www.squaremobius.net/amqp.node/doc/ssl.html).\n\n```javascript\n\tconnection: { \t\t// sample connection hash\n\t\tcaPath: '', \t// comma delimited paths to CA files. RABBIT_CA\n\t\tcertPath: '', \t// path to cert file. RABBIT_CERT\n\t\tkeyPath: '',\t// path to key file. RABBIT_KEY\n\t\tpassphrase: '', // passphrase associated with cert/pfx. RABBIT_PASSPHRASE\n\t\tpfxPath: ''\t\t// path to pfx file. RABBIT_PFX\n\t}\n```\n\n## Channel Prefetch Limits\n\nWascally mostly hides the notion of a channel behind the scenes, but still allows you to specify channel options such as the channel prefetch limit. Rather than specifying\nthis on a channel object, however, it is specified as a `limit` on a queue defintion.\n\n```js\nqueues: [{\n  // ...\n\n  limit: 5\n}]\n\n// or\n\nrabbit.addQueue(\"some.q\", {\n  // ...\n\n  limit: 5\n});\n```\n\nThis queue configuration will set a prefetch limit of 5 on the channel that is used for consuming this queue.\n\n**Note:** The queue `limit` is not the same as the `queueLimit` option - the latter of which sets the maximum number of messages allowed in the queue.\n\n## Additional Learning Resources\n\n### Watch Me Code\nThanks to Derick Bailey's input, the API and documentation for wascally have improved a lot. You can learn from Derick's hands-on experience in his [Watch Me Code](https://sub.watchmecode.net/categories/rabbitmq/) series.\n\n### RabbitMQ In Action\nAlvaro Vidella and Jason Williams literally wrote the book on [RabbitMQ](http://www.manning.com/videla/).\n\n### Enterprise Integration Patterns\nGregor Hophe and Bobby Woolf's definitive work on messaging. The [site](http://www.enterpriseintegrationpatterns.com/) provides basic descriptions of the patterns and the [book](http://www.amazon.com/Enterprise-Integration-Patterns-Designing-Deploying/dp/0321200683) goes into a lot of detail.\n\nI can't recommend this book highly enough; understanding the patterns will provide you with the conceptual tools need to be successful.\n\n## Contributing\nPRs with insufficient coverage, broken tests or deviation from the style will not be accepted.\n\n### Behavior & Integration Tests\nPRs should include modified or additional test coverage in both integration and behavioral specs. Integration tests assume RabbitMQ is running on localhost with guest/guest credentials and the consistent hash exchange plugin enabled. You can enable the plugin with the following command:\n\n```bash\nrabbit-plugins enable rabbitmq_consistent_hash_exchange\n```\n\nRunning gulp will run both sets after every file change and display a coverage summary. To view a detailed report, run gulp coverage once to bring up the browser.\n\n### Style\nThis project has both an `.editorconfig` and `.esformatter` file to help keep adherance to style simple. Please also take advantage of the `.jshintrc` file and avoid linter warnings.\n\n## Roadmap\n * additional test coverage\n * support RabbitMQ backpressure mechanisms\n * (configurable) limits & behavior when publishing during connectivity issues\n * ability to capture/log unpublished messages on shutdown\n * add support for Rabbit's HTTP API\n * enable better cluster utilization by spreading connections out over all nodes in cluster\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/leankit-labs/wascally/issues"
  },
  "homepage": "https://github.com/leankit-labs/wascally",
  "_id": "wascally@0.2.4",
  "_from": "wascally@^0.2.4"
}
