{
  "name": "zero-config",
  "version": "6.0.2",
  "description": "A zero configuration configuration loader",
  "keywords": [],
  "author": {
    "name": "Raynos",
    "email": "raynos2@gmail.com"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/uber/zero-config.git"
  },
  "main": "index",
  "homepage": "https://github.com/uber/zero-config",
  "bugs": {
    "url": "https://github.com/uber/zero-config/issues",
    "email": "raynos2@gmail.com"
  },
  "dependencies": {
    "config-chain": "^1.1.8",
    "deep-extend": "^0.2.11",
    "dotty": "0.0.2",
    "error": "^4.1.1",
    "flatten-prototypes": "^3.0.0",
    "minimist": "^1.1.0",
    "process": "^0.7.0",
    "raynos-rust-result": "0.1.0-improvement3",
    "clone": "~0.2.0"
  },
  "devDependencies": {
    "coveralls": "^2.10.0",
    "fixtures-fs": "^1.0.2",
    "istanbul": "^0.2.7",
    "jshint": "^2.5.0",
    "opn": "^0.1.2",
    "pre-commit": "0.0.5",
    "tap-spec": "^0.2.0",
    "tape": "^2.14.0"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/uber/zero-config/raw/master/LICENSE"
    }
  ],
  "scripts": {
    "test": "npm run jshint -s && node test/index.js | tap-spec",
    "unit-test": "node test/index.js | tap-spec",
    "jshint-pre-commit": "jshint --verbose $(git diff --cached --name-only | grep '\\.js$')",
    "jshint": "jshint --verbose $(git ls-files | grep '\\.js$')",
    "cover": "istanbul cover --report none --print detail test/index.js",
    "view-cover": "istanbul report html && opn ./coverage/index.html",
    "travis": "npm run cover -s && istanbul report lcov && ((cat coverage/lcov.info | coveralls) || exit 0)"
  },
  "engine": {
    "node": ">= 0.8.x"
  },
  "pre-commit": [
    "jshint-pre-commit",
    "unit-test"
  ],
  "playdoh-version": "2.5.0",
  "readme": "# zero-config\n\n[![build status][build-png]][build]\n[![Coverage Status][cover-png]][cover]\n[![Davis Dependency status][dep-png]][dep]\n\n<!-- [![NPM][npm-png]][npm] -->\n\n<!-- [![browser support][test-png]][test] -->\n\nA zero configuration configuration loader\n\n## Example\n\n```js\n// config/common.json\n{\n    \"port\": 9001\n}\n```\n\n```js\n// config/production.json\n{\n    \"redis\": {\n        \"host\": \"localhost\",\n        \"port\": 6379\n    }\n}\n```\n\n```js\n// server.js\nvar fs = require('fs')\nvar fetchConfig = require('zero-config')\n\nvar config = fetchConfig(__dirname, {\n    dcValue: fs.existsSync('/etc/zero-config/datacenter') ?\n        fs.readFileSync('/etc/zero-config/datacenter', 'utf8') :\n        null\n})\n\nvar port = config.get(\"port\")\nvar redisConf = config.get(\"redis\")\nvar redisPort = config.get(\"redis.port\")\n```\n\nYou can also call the process with\n    `node server.js --port 10253` to change the config \n    information from the command line\n\n## Docs\n\n### `var config = fetchConfig(dirname, opts)`\n\n```ocaml\ntype Keypath : String | Array<String>\n\ntype Config : {\n    get: (keypath?: Keypath) => Any,\n    set: ((keypath: Keypath, value: Any) => void) &\n        (value: Any) => void,\n    freeze: () => void,\n    clone: () => Config\n    getRemote: (keypath?: Keypath) => Any,\n    setRemote: ((keypath: Keypath, value: Any) => void) &\n        (value: Any) => void\n}\n\nzero-config := (dirname: String, opts?: {\n    argv?: Array<String>,\n    dcValue?: String,\n    blackList?: Array<String>,\n    env?: Object<String, String>,\n    seed?: Object<String, Any>,\n    defaults?: Object<String, Any>\n}) => Config\n```\n\n`fetchConfig` takes the current __dirname as an argument, it \n  assumes that there exists a config folder at `./config` in \n  your project and it assumes there exists a `common.json` and a\n  `NODE_ENV.json` for each environment.\n\nIt returns you a `config` object with a `get(keypath)` method\n  to fetch properties out of config. `get()` takes a keypath,\n  i.e. `\"prop.nested.someKey\"`to get direct or nested properties\n  in the config object.\n\nIt's recommended you use `.get()` as in the future we will \n  enable dynamic config properties through flipr support.\n\n\n### The config lookup algorithm\n\nThe `fetchConfig()` function tries to fetch config from multiple\n  locations and then deep merges the objects it finds together\n  into a single object.\n\nBelow are the sources it reads in order of least precendence.\n  i.e. the later sources in the list overwrite the earlier ones\n\n - a `config/common.json` JSON file in your project\n - a `config/NODE_ENV.json` JSON file in your project\n - a `config/secrets/secrets.json` JSON file in your project\n containing secrets (API keys, OAuth tokens, etc) only for production\n - a `config/secrets/secrets-NODE_ENV.json` JSON file in your\n project containing secrets per NODE_ENV but not production\n - a `config/NODE_ENV.{datacenter}.json` JSON file in your\n    project if you specificed a datacenter.\n - a `{ datacenter: '{datacenter}' }` literal if you \n    specified a datacenter.\n - a `--config=/var/config/some-file.json` JSON file if you\n    passed a command line argument called `--config` to the\n    process.\n - a object literal based on command line arguments. i.e. if \n    you pass `--foo='bar' --bar.baz='bob'` you will get\n    `{ \"foo\": \"bar\", \"bar\": { \"baz\": \"bob\" } }`\n - a seed object of manual overwrites for testing purposes.\n - a defaults object that populates values that have \n    not been set by any other means.\n\nThe config loader also uses `config-chain` for the actual\n  loading logic so you can read [their docs][config-chain]\n\n#### `dirname`\n\n`dirname` is the directory that is the parent of the `config`\n  directly. If you call `fetchConfig` in a file located in the \n  root directory you can just pass `__dirname` as config lives\n  at `./config`.\n\nIf you require `fetchConfig` anywhere else like `./api/server.js`\n  you will have to pass `path.join(__dirname, '..')`\n\n#### `opts`\n\n`opts` is an optional object, that contains the following\n  properties.\n\n**Note** that `opts` is only optional in environments other then\n  `\"production`\". If your `process.env.NODE_ENV` is set to\n  `\"production\"` then you **MUST** specifiy `opts` and specify\n  the `opts.dcValue` parameter.\n\nRunning a production service without knowing how to load \n  datacenter specific configuration is a bug.\n\n#### `opts.dcValue`\n\n`opts.dcValue` is either `null` or a datacenter name.\n\nSay you have two datacenters, EC2-west and EC2-east. It's \n  recommended that you have a file called `/etc/datacenter`\n  that contains either the string `EC2-west` or `EC2-east`.\n\nThis way any service can know what datacenter it is running\n  in with a simple `cat /etc/datacenter`.\n\nYou can then call `fetchConfig(...)` with the datacenter value\n  by calling `fs.readFileSync('/etc/datacenter')`\n\nNote that if you pass the dc config to `fetchConfig` then the\n  config object will contain the `\"datacenter\"` key whose value\n  is either `EC2-west` or `EC2-east` or whatever your datacenter\n  names are.\n\nWe will also load the file `config/production.EC2-west.json`\n  and merge that into the config tree.\n\n#### `opts.argv`\n\n`opts.argv` is optional and probably not needed\n\n`fetchConfig` will read your process argv information using\n  the [`minimist`][minimist] module.\n\nIf you do not want `fetchConfig` to read global argv for you,\n  you can pass in an `argv` object with keys like `'foo'` and\n  `'bar.baz''` and values that are strings / numbers / booleans\n\n#### `opts.blackList`\n\n`opts.blackList` is an optional array of argv keys to blacklist.\n\n`fetchConfig` by default converts all command line arguments to\n  configuration keys. If you want to pass a non config key \n  command line argument like `--debug` or `--restart-fast`, etc.\n  then you might want to add them to the `blackList`\n\nIf your `opts.blackList` is `['debug']` then `config.get('debug')`\n  will not resolve to the `--debug` command line argument.\n\n#### `opts.env`\n\n`opts.env` is optional and probably not needed.\n\n`fetchConfig` will read the env using `process.env`. The only\n  property it reads is an environment variable called `NODE_ENV`.\n\nIf you prefer to not have this variable configured through\n  the environment or want to call it something else then you\n  can pass in `{ NODE_ENV: whatever }` as `opts.env`\n\n#### `opts.loose`\n\nshould a value be requested from the config using get() and the\n  key does not exist an error will be thrown. By setting\n  `opts.loose` to `true` this feature is disabled and a value of\n  undefined is returned should this key not be preset in the\n  config.\n\n#### `opts.seed`\n\n`opts.seed` is optional, it can be set to an object\n\nIf it exists we will merge the seed object into the config\n  data we have fetched. seed overwrites all the other sources\n  of configuration.\n\nThe `seed` option is very useful for testing purposes, it allows\n  you to overwrite the configuration that your application would\n  load with test specific properties.\n\nThis is an alternative to the `NODE_ENV=test `pattern, we highly\n  recommend that you do not have a `test.json` file at all.\n\n#### `opts.defaults`\n\n`opts.defaults` is optional, it can be set to an object.\n\nIf it exists, it will populate all the values that are unset \n  (but not undefined) in the loaded config with those in \n  `opts.defaults`.\n\nThe difference between `defaults` and `seed` is that `seed` over-\n  writes set values, while `defaults` does not.\n\n#### `var value = config.get(keypath)`\n\n`config.get(keypath)` will return the value at a keypath. The \n  `keypath` must be a string.\n\nYou can call `config.get('port')` to get the port value. You\n  can call `config.get('playdoh-logger.kafka.port')` to get\n  the nested kafka port config option.\n\n#### `config.set(keypath, value)`\n\n`config.set(keypath, value)` will set a value at the keypath.\n\nYou can call `config.set(\"port\", 9001)` to set the port value.\n  You can call `config.set(\"playdoh-logger.kafka.port\", 9001)` to\n  set then nested kafka port config option.\n\nNote you can also call `config.set(entireObject)` to merge an\n  entire object into the `config` instance. This will use \n  deep extend to set all the key / value pairs in `entireObject`\n  onto the config instance.\n\n#### `config.freeze()`\n\nSince the `config` object is supposed to represent a set of\n  static, immutable configuration that's loaded at process\n  startup time it would be useful to enforce this.\n\nOnce you are ready to stop mutating `config` you can call\n  `.freeze()`. Any future calls to `.set()` will throw a \n  config frozen exception.\n\nNote that you can always call `config.setRemote()` as that is\n  not effected by `.freeze()`\n\n#### `config.clone()`\n\nTo get a deep clone of the config object, use `config.clone()`.\nA cloned config object will have the same underlying data but\nnone of the other properties. For example, if you clone a frozen\nconfig object, you are able to make changes to the clone but not\nthe original object.\n\n#### `var value = config.getRemote(keypath)`\n\nThe same as `config.get()` but gets from a different in memory\n  object then `config.get()`.\n\nIt's recommended that you use `config.get()` and `config.set()`\n  for any local configuration that is static and effectively\n  immutable after process startup.\n\nYou can use `config.getRemote()` and `config.setRemote()` for\n  any dynamic configuration that is effectively controlled\n  remotely outside your program.\n\n#### `config.setRemote(keypath, value)`\n\nThe same as `config.set()` but sets to a different in memory\n  objec then `config.set()`.\n\nYou can use `config.getRemote()` and `config.setRemote()` for\n  any dynamic configuration that is effectively controlled\n  remotely outside your program.\n\n## Installation\n\n`npm install zero-config`\n\n## Tests\n\n`npm test`\n\n## Best Practices\n\nZero-config is designed to help you structure your config \nfiles to support a number of production concerns. These best\n practices reflect our approach and some of the reasons we \n designed Zero-config as we did.\n\n - Configuration should live in a single file\n - Only put configuration in more specific configuration \nfiles when you really have to. Dev and test configs should \nonly contain changes to support development \n(e.g. turning off caching).\n - Put your secrets in a `secrets.json` so that they are \neasier to manage safely. Ideally never commit these files \nto your source control repository. This is why we keep secrets\nin a folder that is easy to symlink\n - If you must have development secrets in source control\n for developer convenience then try to scrub them from\n builds of your projects. We call these `secrets-ENV.json` to\n make that easy.\n\n## Contributors\n\n - Raynos\n - sh1mmer\n\n## MIT Licenced\n\n  [build-png]: https://secure.travis-ci.org/uber/zero-config.png\n  [build]: https://travis-ci.org/uber/zero-config\n  [cover-png]: https://coveralls.io/repos/uber/zero-config/badge.png\n  [cover]: https://coveralls.io/r/uber/zero-config\n  [dep-png]: https://david-dm.org/uber/zero-config.png\n  [dep]: https://david-dm.org/uber/zero-config\n  [test-png]: https://ci.testling.com/uber/zero-config.png\n  [tes]: https://ci.testling.com/uber/zero-config\n  [npm-png]: https://nodei.co/npm/zero-config.png?stars&downloads\n  [npm]: https://nodei.co/npm/zero-config\n",
  "readmeFilename": "README.md",
  "_id": "zero-config@6.0.2",
  "dist": {
    "shasum": "0444b9e1f0f6ebaf4fba939deefb7ecdc7301513"
  },
  "_from": "zero-config@^6.0.2",
  "_resolved": "https://registry.npmjs.org/zero-config/-/zero-config-6.0.2.tgz"
}
