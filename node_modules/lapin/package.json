{
  "name": "lapin",
  "version": "3.0.0",
  "description": "RPC library for AMQP protocol",
  "main": "index.js",
  "scripts": {
    "test": "make test-cov"
  },
  "repository": {
    "type": "git",
    "url": "git@github.com:School-Improvement-Network/lapin.git"
  },
  "author": {
    "name": "School Improvement Network"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/School-Improvement-Network/lapin/issues"
  },
  "homepage": "https://github.com/School-Improvement-Network/lapin",
  "dependencies": {
    "rabbus": "^0.2.1"
  },
  "devDependencies": {
    "code": "^1.2.1",
    "lab": "^5.2.0",
    "proxyquire": "^1.3.1",
    "sinet-coding-conventions": "^1.14.0",
    "sinon": "^1.12.2",
    "wascally": "~0.2.0-7"
  },
  "readme": "## Lapin wrapper for [RabbitMQ](http://rabbitmq.com/)\n\nCurrently this project is using [Rabbus](https://github.com/derickbailey/rabbus) and [Wascally](https://github.com/LeanKit-Labs/wascally). This project is aiming to support several producer / consumer patterns. The following are is a list of the planned patterns, and the checked ones are currently implemented:\n\n* [X] Send / Receive\n* [X] Publish / Subscribe\n* [X] Request / Response\n\nThe [JSend](http://labs.omniti.com/labs/jsend) specification is required to determine if an error has occurred in a response.\n\n## Installation an usage\n\nAs lapin uses wascally you need to install it along with lapin:\n\n```bash\nnpm install wascally\nnpm install lapin\n```\n\nRequire lapin and wascally:\n\n```javascript\nvar rabbit = require( 'wascally' );\nvar lapin  = require( 'lapin' )( rabbit );\n```\n\nThe following are simple usage examples:\n\n**Send / Receive**\n\n```javascript\n// Sender\nvar sender = lapin.sender( { 'messageType' : 'v1.logs.log' } );\nsender.produce( message, function ( error, response ) {\n\n\t// handling the response is optional\n\tif ( !error ) {\n\t\tconsole.log( response );\n\t}\n\n} );\n\n// Receiver\nvar receiver = lapin.receiver( { 'messageType' : 'v1.logs.log' } );\nreceiver.consume( function ( message, done ) {\n\n  someDatabaseQuery( message, function ( err, body ) {\n\n    if ( err ) {\n      throw err;\n    }\n\n    done();\n\n  } );\n\n} );\n```\n\n**Publish / Subscribe**\n\n```javascript\n// Publisher\nvar publisher = lapin.publisher( { 'messageType' : 'v1.users.login' } );\npublisher.produce( message, function ( error, response ) {\n\n    // handling the response is optional\n\tif ( !error ) {\n\t\tconsole.log( response );\n\t}\n\n} );\n\n\n// Subscriber\nvar subscriber = lapin.receiver( { 'messageType' : 'v1.users.login' } );\nsubscriber.consume( function ( message, done ) {\n\n  someDatabaseQuery( message, function ( err, body ) {\n\n    if ( err ) {\n      throw err;\n    }\n\n    done();\n\n  } );\n\n} );\n```\n\n**Request / Response**\n\n```javascript\n// Requester\nvar requester = lapin.requester( { 'messageType' : 'v1.users.findAll' } );\nrequester.produce( message, function ( error, data ) {\n\n\tif ( error ) {\n\t\treturn reply( error ).code( 500 );\n\t}\n\n\treturn reply( data.data );\n} );\n\n// Responder\nvar responder = lapin.responder( { 'messageType' : 'v1.users.findAll' } );\nresponder.consume( function ( message, respond ) {\n\n\tsomeDatabaseQuery().success( function ( result ) {\n\n\t\t// JSend success with data\n\t\trespond( {\n\t\t\t'status' : 'success',\n\t\t\t'data'   : result\n\t\t} );\n\n\t} ).error( function handleError ( error ) {\n\n\t\t// JSend error\n\t\trespond( {\n\t\t\t'status' : 'error',\n\t\t\t'data'   : error\n\t\t} );\n\n\t} );\n\n} );\n```\n\n## Contributing\nAll pull requests must follow [coding conventions and standards](https://github.com/School-Improvement-Network/coding-conventions).\n\n\n## Additional Information\n#### RPC over RabbitMQ\n\nIn general, doing RPC over RabbitMQ is easy. A client sends a request message and a server replies with a response message. In order to receive a response the client needs to send a 'callback' queue address with the request.\n\n![RabbitMQ RPC](rabbitmq_rpc.png)\n\n * When the client starts up, it creates an exclusive callback queue.\n * For an RPC request, the Client sends a message with two required properties: `reply_to`, which is set to the callback queue and `correlation_id`, which is set to a unique value for every request.\n * The request is sent to an `rpc_queue` queue.\n * The RPC worker (aka: server) is waiting for requests on that queue. When a message appears, it does the job and sends a message with the result back to the Client, using the queue from the `reply_to` field.\n * The client waits for data on the callback queue. When a message appears, it checks the `correlation_id` property. If it matches the value from the request it returns the response to the application.\n\n## Standards/Conventions\n\n* **messageType:** `<version>`.`<resource>`.`<action>`\n\n* **exchange:** `<pattern>`.`<resource>`-exchange\n\n* **queue:** `<pattern>`.<resource>-queue\n\n###Where\n`Patterns:`\n\n- req-res\n\n- pub-sub\n\n- send-rec\n\n`Version:`\n\n- v1\n\n- v2\n\n- and so on.\n",
  "readmeFilename": "readme.md",
  "_id": "lapin@3.0.0",
  "dist": {
    "shasum": "dacbd2fc7530a439863369dd6367f470abc1108f"
  },
  "_from": "lapin@^3.0.0",
  "_resolved": "https://registry.npmjs.org/lapin/-/lapin-3.0.0.tgz"
}
