{
  "name": "rabbus",
  "version": "0.2.4",
  "description": "A highly opinionated set of messaging abstractions for RabbitMQ, built with Wascally",
  "main": "rabbus/index.js",
  "scripts": {
    "test": "grunt specs"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/derickbailey/rabbus.git"
  },
  "keywords": [
    "rabbitmq",
    "messaging",
    "message",
    "bus",
    "amqplib",
    "wascally",
    "send",
    "receive",
    "pub",
    "sub",
    "request",
    "response"
  ],
  "author": {
    "name": "Derick Bailey"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/derickbailey/rabbus/issues"
  },
  "homepage": "https://github.com/derickbailey/rabbus",
  "devDependencies": {
    "grunt": "^0.4.5",
    "grunt-contrib-jshint": "^0.10.0",
    "grunt-contrib-watch": "^0.6.1",
    "grunt-jasmine-node": "^0.2.1",
    "node-jasmine-async": "^0.1.0",
    "wascally": "^0.2.2"
  },
  "dependencies": {
    "underscore": "^1.7.0",
    "when": "^3.6.3"
  },
  "readme": "# Rabbus: Micro-ESB For NodeJS/RabbitMQ\n\nA highly opinionated, yet minimal, set of message bus abstractions for NodeJS.\nIt is built on top of [RabbitMQ](http://rabbitmq.com), \nwith [Wascally](https://github.com/LeanKit-Labs/wascally) as the primary library\nfor working with RabbitMQ.\n\n## About Rabbus\n\nThe service bus implementation is basic, but includes several of the most \ncommon patterns:\n\n* Send / Receive\n* Publish / Subscribe\n* Request / Response\n\nPlease note that the names of these patterns imply certain things both in\nsemantics and in behaviors. I (@derickbailey) have put my own experience and\nopinions in to these names and the RabbitMQ configuration associated with them.\nSome of the behavior is inherited from Wascally, as well.\n\n## Installing Rabbus\n\nIt's all NPM. You're going to want the 'wascally' package with this, so you will\nneed to do two things:\n\n```\nnpm install --save wascally\nnpm install --save rabbus\n```\n\nPlease note that Wascally is explicitly NOT mentioned as a dependency in the\nRabbus package.json file for runtime dependencies. This is done with intent, to help prevent library\nversion conflicts.\n\n## Using Rabbus\n\nThere are three pairs of objects that come with Rabbus, as noted in the above\npatterns. Each of them is meant to be used in combination with it's pair. You\nare encouraged, however, not to use them directly. While this is certainly\npossible, I find it is more convenient to inherit from these objects at the\npoint where they need to be used. The configuration of each object can then be\nencapsulated for the intended use, allowing easier testing and maintenance.\n\nThere are a few commonalities between all of these object pairs. Most notably,\nthe object that sends a message to RabbitMQ only needs to know about the \nexchange to which it sends. Conversely, the object that consumes a message\nfrom within RabbitMQ needs to know about both the exchange and the queue to \nwhich it subscribes.\n\nThe following provide basic working examples of each object pair. If you would \nlike to run these demos for yourself, please see the [demos folder](demos)\nof the repository.\n\nPlease see the [Wascally](https://github.com/LeanKit-Labs/wascally) documentation for information\non configuring RabbitMQ.\n\n### General Error Handling\n\nIn general, each of the objects in Rabbus will emit an \"error\"\nmessage when an error occurs. You can use standard NodeJS\nEventEmitter functions to subscribe / unsubscribe the error\nevents.\n\n```js\nvar sub = new Subscriber(...);\nsub.on(\"error\", function(err){\n  // do something with the err object, here\n});\n```\n\n### Send / Receive\n\nThe Send / Receive object pair uses a direct exchange inside of RabbitMQ, \nallowing you to specify the binding key.\n\nSet up a Sender:\n\n```js\nvar util = require(\"util\");\nvar Rabbus = require(\"rabbus\");\n\nfunction SomeSender(rabbus){\n  Rabbus.Sender.call(this, rabbus, {\n    exchange: \"send-rec.exchange\",\n    routingKey: \"send-rec.key\",\n    messageType: \"send-rec.messageType\"\n  });\n}\n\nutil.inherits(SomeSender, Rabbus.Sender);\n\nvar sender = new SomeSender(Rabbus);\nvar message = {\n  place: \"world\"\n};\n\nsender.send(message, function(){\n  console.log(\"sent a message\");\n});\n```\n\nSet up a Receiver:\n\n```js\nvar util = require(\"util\");\nvar Rabbus = require(\"rabbus\");\n\nfunction SomeReceiver(rabbus){\n  Rabbus.Receiver.call(this, rabbus, {\n    exchange: \"send-rec.exchange\",\n    queue: \"send-rec.queue\",\n    routingKey: \"send-rec.key\",\n    messageType: \"send-rec.messageType\"\n  });\n}\n\nutil.inherits(SomeReceiver, Rabbus.Receiver);\n\nvar receiver = new SomeReceiver(Rabbus);\n\nreceiver.receive(function(message, done){\n  console.log(\"hello\", message.place);\n  done();\n});\n```\n\n#### Using a CorrelationID with Send/Receive\n\nThe Send/Receive pair optionally allows a `correlationId` to be passed in \nthrough an options object literal, with the `send` and `receive` methods,\nrespectively. Providing a `correlationId` on the send side of things requies\na `receive` request to state the same correlationId. If an incorrect\ncorrelationId, or no correlationId, is specified, then the receiver will \"nack\"\nthe message, sending it back to the queue.\n\nUsing the `SomeSender` and `SomeReceiver` defined above, you can specify\na correlationId to match between them.\n\n```js\n// options with correlationId\n// --------------------------\n\nvar options = {\n  correlationId: \"some-correlation-id\"\n};\n\n// sender\n// ------\n\nvar message = { place: \"world\" };\n\nvar sender = new SomeSender(Rabbus);\nsender.send(message, options, function(){\n  console.log(\"sent a message with a correlationId:\", options.correlationId);\n});\n\n// receiver\n// --------\n\nvar receiver = new SomeReceiver(Rabbus);\n\nreceiver.receive(options, function(message, done){\n  console.log(\"hello\", message.place, \" - with correlationId:\", options.correlationId);\n  done();\n});\n```\n\nA correlationId can be used with any given Send/Receive pair, but you should\nconsider having specific queues / exchange bindings to prevent accidental\nhandling of the correlated message by other handlers.\n\n### Publish / Subscribe\n\nThe Publish / Subscribe object pair uses a fanout exchange inside of RabbitMQ, \nallowing you to have as many subscribers as you need. Think of pub/sub as an\nevent that gets broadcast to anyone that cares, or no one at all if no one is\nlistening.\n\nSet up a Publisher:\n\n```js\nvar util = require(\"util\");\nvar Rabbus = require(\"rabbus\");\n\nfunction SomePublisher(rabbus){\n  Rabbus.Publisher.call(this, rabbus, {\n    exchange: \"pub-sub.exchange\",\n    routingKey: \"pub-sub.key\",\n    messageType: \"pub-sub.messageType\"\n  });\n}\n\nutil.inherits(SomePublisher, Rabbus.Publisher);\n\nvar publisher = new SomePublisher(Rabbus);\nvar message = {\n  place: \"world\"\n};\n\npublisher.publish(message, function(){\n  console.log(\"published an event!\");\n});\n```\n\nSet up a Subscriber:\n\n```js\nvar util = require(\"util\");\nvar Rabbus = require(\"rabbus\");\n\nfunction SomeSubscriber(rabbus){\n  Rabbus.Subscriber.call(this, rabbus, {\n    exchange: \"pub-sub.exchange\",\n    queue: \"pub-sub.queue\",\n    routingKey: \"pub-sub.key\",\n    messageType: \"pub-sub.messageType\"\n  });\n}\n\nutil.inherits(SomeSubscriber, Rabbus.Subscriber);\n\nvar sub1 = new SomeSubscriber(Rabbus);\nsub1.subscribe(function(message){\n  console.log(\"1: hello\", message.place);\n});\n\nvar sub2 = new SomeSubscriber(Rabbus);\nsub2.subscribe(function(message){\n  console.log(\"2: hello\", message.place);\n});\n\nvar sub3 = new SomeSubscriber(Rabbus);\nsub3.subscribe(function(message){\n  console.log(\"3: hello\", message.place);\n});\n```\n\n### Request / Response\n\nThe request/response pair uses a \"topic\" exchange. You should set the\nrouting key via the \"routingKey\" parameter, but it will default to the \nmessage type if none is supplied.\n\nWith a request/response setup, you can send a request for information and\nrespond to it. A private, temporary queue will be created for the response\nmessage, ensuring that it gets back to the requester correctly.\n\nSet up a Requester\n\n```js\nvar util = require(\"util\");\nvar Rabbus = require(\"rabbus\");\n\nfunction SomeRequester(rabbus){\n  Rabbus.Requester.call(this, rabbus, {\n    exchange: \"req-res.exchange\",\n    messageType: \"req-res.messageType\",\n    routingKey: \"req-res.key\"\n  });\n}\n\nutil.inherits(SomeRequester, Rabbus.Requester);\n\nvar requester = new SomeRequester(Rabbus);\n\nvar msg = {};\nrequester.request(msg, function(response, done){\n  console.log(\"Hello\", response.place);\n  done();\n});\n```\n\nSet up a Responder:\n\n```js\nvar util = require(\"util\");\nvar Rabbus = require(\"rabbus\");\n\nfunction SomeResponder(rabbus){\n  Rabbus.Responder.call(this, rabbus, {\n    exchange: \"req-res.exchange\",\n    queue: \"req-res.queue\",\n    routingKey: \"req-res.key\",\n    limit: 1,\n    messageType: \"req-res.messageType\"\n  });\n}\n\nutil.inherits(SomeResponder, Rabbus.Responder);\n\nvar responder = new SomeResponder(Rabbus);\n\nresponder.handle(function(message, respond){\n  respond({\n    place: \"world\"\n  });\n});\n```\n\nNote that the responder does the \"work\" but sends a response back to the\nrequester, instead of just saying that the work is done. This allows the\nrequester to receive the response and do something with it.\n\nAlso note the \"limit\" option for the Resonder. This is the \"prefetch\" limit\nfor the queue, allowing you to limit the amount of work being done concurrently.\n\n## Limit Message Processing\n\nIf you need to limit the number of messages being processed by any given\nmessgae handler, you can specify a `limit` in the configuration.\n\n```\nfunction SomeSubscriber(rabbus){\n  Rabbus.Subscriber.call(this, rabbus, {\n    // ...\n    limit: 1\n  });\n}\n```\n\nThis will limit your `SomeSubscriber` to only working on one message at a time.\nWhen your processing code calls `done`, the next message will be picked up\nand processed.\n\n## Force Message Acknowledgement\n\nThe default behavior of Wascally is to batch process `msg.ack()` calls. While\nthis is beneficial in many cases, it can cause problems. If you need to force\nacknowledgement of individual messages, this can be done using the `forceAck`\noption in Rabbus' constructors. This option will call Wascally's `batchAck()`\nafter each `msg.ack()` is called.\n\n```js\nvar Subscriber = new Rabbus.Subscriber({\n  // ...\n\n  forceAck: true\n});\n```\n\nThe following Rabbus objects provide the `forceAck` feature:\n\n* Rabbus.Receiver\n* Rabbus.Subscriber\n* Rabbus.Requester (force ack on response message)\n* Rabbus.Responder (force ack on request message);\n\n## Legalese\n\nUnless otherwise noted, Rabbus is Copyright &copy;2014 Muted Solutions, LLC. All Rights Reserved. \n\nRabbus is distributed under the [MIT license](http://mutedsolutions.mit-license.org).\n",
  "readmeFilename": "readme.md",
  "_id": "rabbus@0.2.4",
  "dist": {
    "shasum": "9757342e64f2f7a4e418d26be0fc644b1b3bd2d8"
  },
  "_from": "rabbus@^0.2.1",
  "_resolved": "https://registry.npmjs.org/rabbus/-/rabbus-0.2.4.tgz"
}
